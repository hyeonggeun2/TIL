## 9강(객체 리터럴)

### 객체란?

- 객체는 다양한 타입의 값(원시 타입의 값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료 구조다.

- 객체는 키와 값으로 구성된 프로퍼티들의 집합이다.

  ```javascript
  var person = {
      name : 'Lee', // 프로퍼티
      gender : 'male'
  };
  // name, gender : 프로퍼티 키, 'Lee', 'male' : 프로퍼티 값,
  ```

  - 프로퍼티 값이 함수라면 '메소드'라고 부른다.

    ```javascript
    var counter = {
        num: 0;
        increase: function () { // 메소드
            this.num++;
        }
    };
    ```

- 즉 객체는 프로퍼티, 메소드로 구성된 집합체이다. 프로퍼티는 객체의 상태를 나타내는 값이고, 메소드는 프로퍼티를 참조하고 조작할 수 있는 동작이다.

### 객체 리터럴에 의한 객체 생성

- 리터럴 표기법으로 중괄호 내에 0개 이상의 프로퍼티를 정의하여서 객체를 생성할 수 있다.
- 프로퍼티가 여러개면 ','을 붙여서 나누고, 끝났을 때 ';'을 붙여줘야함을 유의하자.

### 프로퍼티

- 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는다면 ''로 묶어주어야 한다.

- 문자열 또는 문자열을 반환하는 표현식을 사용하여 프로퍼티 키를 생성할 수 있다. 이를 계산된 프로퍼티 이름이라고 한다.

  ```javascript
  var obj = {};
  var key = 'hello';
  
  obj[key] = 'world'; // obj = {hello: 'world'}
  ```

- 빈 문자열도 프로퍼티 키로 사용할 수 있다. 프로퍼티 키는 암묵적 타입 변환을 통해 문자열이 된다. var과 같은 예약어도 프로퍼티 키로 사용할 수 있다. 프로퍼티 키가 중복되면 나중에 선언된 프로퍼티로 덮어쓴다.

  ```javascript
  var foo = {
    '': '',
    0: 1,
    var: 'var', // 에러가 발생하진 않지만 사용을 권장하진 않는다
    name: 'Lee',
    name: 'Kim' // Kim으로 덮어쓴다.
  };
  ```

### 메소드

- 메소드는 객체에 제한되어 있는 함수를 의미한다.

### 프로퍼티 접근

- 마침표 표기법과 대괄호 표기법이 있다.

  ```javascript
  var person = {
      name: 'Lee',
      'last-name': 'Kim',
      1: 10
  };
  
  person.name;
  person['name'] // person[name]은 레퍼런스오류가 난다.
  person.age; // 존재하지 않는 객체에 접근하면 undefined를 반환한다.
  person['last-name']; // ''로 감싸진 프로퍼티 키에 접근하고싶으면 대괄호 표기법을 사용하여야 한다.
  person.[1]; // person['1']도 가능하다.
  ```

### 프로퍼티 값 갱신

- 프로퍼티에 접근하여 값을 갱신할 수 있다.

  ```javascript
  var person = {
      name: 'Lee'
  };
  
  person.name = 'Kim';
  ```

### 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하여 프로퍼티를 생성할 수 있다.

  ```javascript
  var person = {
      name: 'Lee'
  };
  
  person.age = 24;
  ```

### 프로퍼티 삭제

- delete 연산자를 통해 프로퍼티를 삭제할 수 있다.

  ```javascript
  var person = {
      name : 'Lee'
  };
  
  delete person.name;
  delete person.age; // 프로퍼티가 없지만 에러는 발생하지 않는다.
  ```

### ES6에서 추가된 객체 리터럴의 확장기능

- 프로퍼티 축약 표현

  ```javascript
  let x = 1, y = 2;
  const obj = { x, y }; // obj = {x: 1, y: 2};
  ```

- 프로퍼티 키 동적 생성

  ```
  var prefix = 'prop';
  var i = 0;
  
  var obj = {
  	[`${prefix}-${++i}`]: i;
  };
  
  obj[prefix + '-' + ++i] = i;
  ```

- 메소드 축약 표현

  ```javascript
  var obj = {
      name: 'Lee',
      sayHi: function() {
          console.log('Hi!' + this.name);
      },
      sayBye() { // 축약표현
          console.log(`Bye! ${this.name}`); 
      }
  }
  ```

## 10강(원시 값과 객체의 비교)

### 원시 값

- 변경 불가능한 값

  - 원시 값에 할당을 하면 새로운 메모리에 값을 적고 식별자는 새로운 메모리를 참조한다.
  - 원시 값은 사실 실제 값이 변경되는 것이 아니라 '재할당' 됐을 뿐이다. 

- 문자열과 불변성

  - 문자열은 '유사 배열 객체'이다. 이는 배열처럼 인덱스로 값에 접근할 수 있고, length를 가진 것을 말한다.

    ```javascript
    var str = 'string';
    
    console.log(str); // string
    str[0] = 'S'; //
    console.log(str);// string (오류는 발생하지 않지만 원시값이므로 값은 변경되지 않는다.)
    ```

- 값에 의한 전달

  - 변수에 변수를 할당하면 값이 복사되어서 전달된다. 두 변수가 같은 메모리를 가르키는 것이 아니다.

### 객체

- 변경 가능한 값
  - 객체는 프로퍼티 값을 갱신할 수 있고, 생성과 삭제도 가능하다. 즉 객체는 변경 가능한 값이다.
- 참조에 의한 전달
  - 객체가 메모리에 생성되면 객체 식별자는 프로퍼티들의 집합이 있는 주소를 값으로 가지게 된다. 때문에, 변수에 객체를 할당하면 메모리가 다른 여러개의 식별자가 하나의 객체를 가르키고 있는 것이다.
