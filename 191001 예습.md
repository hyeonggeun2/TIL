# 자바스크립트

## 3강

- 자바스크립트는 브라우저 환경에서도 실행할 수 있고, Node.js 환경에서도 실행할 수 있다. 
  - **브라우저 환경에서는 화면에 렌더링**하는것이 주 목적이고 **Node.js 환경에서는 서버 개발 환경을 제공**하는 것이 주 목적이다.
  - 두 환경모두 ECMAScript를 제공하며 **각자 제공하는 API가 있다.**
- 브라우저의 핵심기능은 서버에 요청하고 서버의 응답을 받아 브라우저에 표시하는 것이다.
- 브라우저는 렌더링 엔진이 DOM(웹 브라우저가 HTML페이지를 인식하는 방식)을 통해 페이지를 생성하다가 script태그를 만나면 자바스크립트 엔진으로 권한을 넘긴다.
  - 자바스크립트는 인터프리터로 컴파일러와 다르게 런타임중 한 줄씩 컴파일 하게된다.
  - 실행의 순서는 토크나이징(의미를 갖는 코드를 최소단위인 토큰으로 분리) -> 파싱(토큰의 집합을 분석하여 추상적 트리 생성) -> 코드실행순이다. 실행이 완료되면 다시 DOM 생성을 재개한다.
  - **DOM이 완전히 생성되지 않은 상태에서 script를 만나고 코드를 실행하게 되면 병목현상으로 오류가 생길 수 있다. 때문에 <body>태그의 마지막에 script를 작성하는 방법을 사용했었다. HTML5에서는 async, defer속성이 생겨서 병목현상을 막아준다.**
    - **async** : 웹페이지 파싱과 스크립트 파일의 다운로드가 동시에 진행되고, 스크립트는 다운로드 완료 직후 실행된다. (IE9 이하 버전은 지원하지 않는다.)
    - **defer** : async와 같이 동시에 다운로드 되는데, 파싱완료 후 스크립트가 실행된다. (IE9 이하 버전은 정상적으로 동작하지 않을 수 있다.)

- 크롬에서 지원하는 개발자도구를 사용하여 다양한 기능을 사용할 수 있다.
  - **Elements** : DOM과 CSS를 편집할 수 있고, 렌더링 된 뷰를 확인할 수 있다. 편집 내용은 저장되지 않는다.
  - **Console** : 페이지의 에러를 확인하거나, 자바스크립트 코드 내부의 console.log 메소드(화면에 값을 출력하는 메소드)의 결과를 확인할 수 있다.
  - **Sources** : 페이지의 자바스크립트 코드를 디버깅할 수 있다.
  - **Network** : 페이지에 관련한 네트워크 요청정보와 퍼포먼스를 확인할 수 있다.
  - **Application** : 웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있다.

- Node.js는 주로 서버 사이드 애플리케이션 개발에 사용되며 SPA에 사용하기 적합하다. CPU 사용률이 높은 애플리케이션에는 권장하지 않는다.
  - Node.js에서는 npm(node package manager)라는 모듈을 모아둔 저장소를 다운로드 받아서 사용할 수 있다.

## 4강

- 값을 재사용하기 위해서 **변수**를 사용한다. **변수(Variable)**는 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다.

  - 변수이름을 정할 땐 명명한 이름을 사용해야한다. 이는 협업과 품질 향상에 도움을 준다.

  - 값을 여러개 저장하기 위해 배열이나 객체를 사용할 수 있다.

    - ```객체 사용
      var user = {
          name : 'Lee',
          role : 'Admin'
      };
      ```

    - ```배열/객체 사용
      var users =[
      	{name: 'Lee', role: 'Admin'},
      	{name: 'Kim', role: 'Developer'}
      ];
      ```

      

      

- 변수에 값을 저장하는 것을 **할당(assignment 대입, 저장)**이라 하고 값을 읽는 것을 **참조(reference)**라고 한다.
- 변수이름(식별자)은 메모리 주소를 기억하고 그 메모리 내에는 값이 저장되어있다.

- 변수는 선언단계와 초기화단계의 2단계를 거친다. var, let키워드로 선언(declaration)할 수 있으며, 값을 초기화하지 않으면 'undefined'로 초기화된다.

- 변수를 선언하지 않고 참조하려고 하면 ReferenceError이 발생한다.
- 변수의 초기화가 선언보다 먼저 적혀있더라도 자바스크립트의 고유 특징인 **변수 호이스팅** 기능때문에 선언이 먼저 되어서 undefined가 나오지 않는다.

- 변수에 값을 할당할 때 이전에 초기화된 undefined를 삭제하고 그 공간에 새로운 값을 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 넣는다.
  - 이전 불필요한 값들은 **가비지 컬렉터(Garbage Collector)에 의해 메모리가 자동 해제**된다. (매니지드 언어인 자바스크립트가 내장하고 있는 기능이다.)
    - 매니지드 언어 : 개발자가 직접 메모리를 제어할 수 없는 언어를 말한다. (C언어와 같은 언매니지드 언어는 malloc(), free()등을 통해 메모리를 직접 관리한다. 개발자의 역량에 따라 최적의 퍼포먼스를 확보할수도, 치명적인 오류를 생산할 수도 있다.)

- 변수와 다르게 값이 변하지 않는 수를 **상수**라고 한다. ES6에 추가된 **const 키워드**를 사용하여 선언할 수 있다. const 키워드는 반드시 상수만을 위해서 사용되진 않는다.
- 변수를 선언할 때 식별자의 이름은 특수문자를 제외한 문자, 숫자, _, $를 포함할 수 있고, 숫자로 시작하면 안된다.
  - ES5부터 유니코드 문자를 허용하여 변수 이름을 한글이나, 일본어 등으로 만들 수 있지만 바람직하지 않으므로 권장하지 않는다.
  - class const else 등 언어에서 사용되고 있거나, 사용될 예정인 단어들은 '예약어' 라고 부르며 식별자로 사용할 수 없다.
  - 자바스크립트는 대소문자를 구분하므로 변수이름을 정할때 주의해야한다.
- 하나 이상의 영어 단어로 구성된 식별자를 네이밍하는 경우 카멜 케이스, 스네이크 케이스, 파스칼 케이스, 헝가리언 케이스가 있다.
  - **카멜 케이스** : var firstName;
  - **스네이크 케이스** : first_name;
  - **파스칼 케이스** : var FristName;
  - **헝가리언 케이스** : var strFirstName; , var $elem = $('.myClass')
  - 가장 일반적으로는 **변수, 함수 이름에는 카멜케이스** 를 사용하고, **생성자 함수, 클래스 이름에는 파스칼 케이스**를 사용하는 방법이다.
